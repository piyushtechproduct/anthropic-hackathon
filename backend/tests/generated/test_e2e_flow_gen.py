"""
Category: E2E Flow
What it tests: End-to-end request flows through the multi-platform intent and
    rank endpoints — full prompt-to-URL validation, dual-platform output
    (Amazon + Flipkart), price format ("Under ₹X"), delivery mapping (Prime /
    Flipkart Assured), brand extraction, rating filter ("4★ & up"), discount
    filter, complex multi-filter prompts, rank with platform diversity,
    multi-step intent→rank pipeline, no-filter prompts, product metadata
    preservation, all spec filter types, and URL encoding of search terms.
How tests work: Each test mocks the Anthropic client so no real API calls are
    made. The FastAPI app is exercised via httpx AsyncClient with ASGITransport.
Test count: 14
Generated by: QA Agent (qa-gen skill)
"""

import json
from unittest.mock import MagicMock, patch

import pytest
from httpx import ASGITransport, AsyncClient

from src.app.main import app

# Mock responses for different test scenarios
MOCK_FULL_FLOW_RESPONSE = {
    "raw_query": "white tshirt under 500 fast delivery",
    "platforms": [
        {
            "platform": "amazon",
            "search_url": "https://www.amazon.in/s?k=white+tshirt",
            "filters": [
                {"type": "price", "value": "Under ₹500"},
                {"type": "delivery", "value": "Prime"},
                {"type": "color", "value": "White"},
            ],
        },
        {
            "platform": "flipkart",
            "search_url": "https://www.flipkart.com/search?q=white+tshirt",
            "filters": [
                {"type": "price", "value": "Under ₹500"},
                {"type": "delivery", "value": "Flipkart Assured"},
                {"type": "color", "value": "White"},
            ],
        },
    ],
}

MOCK_BRAND_RESPONSE = {
    "raw_query": "nike tshirt under 1000",
    "platforms": [
        {
            "platform": "amazon",
            "search_url": "https://www.amazon.in/s?k=nike+tshirt",
            "filters": [
                {"type": "brand", "value": "Nike"},
                {"type": "price", "value": "Under ₹1,000"},
            ],
        },
        {
            "platform": "flipkart",
            "search_url": "https://www.flipkart.com/search?q=nike+tshirt",
            "filters": [
                {"type": "brand", "value": "Nike"},
                {"type": "price", "value": "Under ₹1,000"},
            ],
        },
    ],
}

MOCK_RATING_RESPONSE = {
    "raw_query": "samsung phone good ratings",
    "platforms": [
        {
            "platform": "amazon",
            "search_url": "https://www.amazon.in/s?k=samsung+phone",
            "filters": [
                {"type": "brand", "value": "Samsung"},
                {"type": "rating", "value": "4★ & up"},
            ],
        },
        {
            "platform": "flipkart",
            "search_url": "https://www.flipkart.com/search?q=samsung+phone",
            "filters": [
                {"type": "brand", "value": "Samsung"},
                {"type": "rating", "value": "4★ & up"},
            ],
        },
    ],
}

MOCK_DISCOUNT_RESPONSE = {
    "raw_query": "running shoes deals",
    "platforms": [
        {
            "platform": "amazon",
            "search_url": "https://www.amazon.in/s?k=running+shoes",
            "filters": [{"type": "discount", "value": "10% off or more"}],
        },
        {
            "platform": "flipkart",
            "search_url": "https://www.flipkart.com/search?q=running+shoes",
            "filters": [{"type": "discount", "value": "10% off or more"}],
        },
    ],
}

MOCK_COMPLEX_RESPONSE = {
    "raw_query": "nike running shoes under 2000 fast delivery good ratings",
    "platforms": [
        {
            "platform": "amazon",
            "search_url": "https://www.amazon.in/s?k=nike+running+shoes",
            "filters": [
                {"type": "brand", "value": "Nike"},
                {"type": "price", "value": "Under ₹2,000"},
                {"type": "delivery", "value": "Prime"},
                {"type": "rating", "value": "4★ & up"},
            ],
        },
        {
            "platform": "flipkart",
            "search_url": "https://www.flipkart.com/search?q=nike+running+shoes",
            "filters": [
                {"type": "brand", "value": "Nike"},
                {"type": "price", "value": "Under ₹2,000"},
                {"type": "delivery", "value": "Flipkart Assured"},
                {"type": "rating", "value": "4★ & up"},
            ],
        },
    ],
}

SAMPLE_MIXED_PRODUCTS = [
    {
        "title": "Amazon White T-Shirt 1",
        "price": 399.0,
        "rating": 4.5,
        "review_count": 250,
        "image_url": "https://example.com/a1.jpg",
        "product_url": "https://amazon.in/product1",
        "platform": "amazon",
    },
    {
        "title": "Flipkart White T-Shirt 1",
        "price": 450.0,
        "rating": 4.3,
        "review_count": 180,
        "image_url": "https://example.com/f1.jpg",
        "product_url": "https://flipkart.com/product1",
        "platform": "flipkart",
    },
    {
        "title": "Amazon White T-Shirt 2",
        "price": 499.0,
        "rating": 4.7,
        "review_count": 320,
        "image_url": "https://example.com/a2.jpg",
        "product_url": "https://amazon.in/product2",
        "platform": "amazon",
    },
    {
        "title": "Flipkart White T-Shirt 2",
        "price": 425.0,
        "rating": 4.6,
        "review_count": 290,
        "image_url": "https://example.com/f2.jpg",
        "product_url": "https://flipkart.com/product2",
        "platform": "flipkart",
    },
    {
        "title": "Amazon White T-Shirt 3",
        "price": 350.0,
        "rating": 4.2,
        "review_count": 150,
        "image_url": "https://example.com/a3.jpg",
        "product_url": "https://amazon.in/product3",
        "platform": "amazon",
    },
    {
        "title": "Flipkart White T-Shirt 3",
        "price": 475.0,
        "rating": 4.4,
        "review_count": 200,
        "image_url": "https://example.com/f3.jpg",
        "product_url": "https://flipkart.com/product3",
        "platform": "flipkart",
    },
]


@pytest.mark.asyncio
async def test_full_flow_prompt_to_intent_to_url_validation():
    """Full flow: prompt → intent extraction → verify URL format and filters"""
    mock_message = MagicMock()
    mock_message.content = [MagicMock(text=json.dumps(MOCK_FULL_FLOW_RESPONSE))]

    with patch("src.app.services.anthropic.Anthropic") as mock_anthropic:
        mock_client = MagicMock()
        mock_client.messages.create.return_value = mock_message
        mock_anthropic.return_value = mock_client

        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as client:
            response = await client.post(
                "/api/intent/multi",
                json={"prompt": "white tshirt under 500 fast delivery"},
            )

    assert response.status_code == 200
    data = response.json()

    # Verify structure
    assert "raw_query" in data
    assert "platforms" in data
    assert len(data["platforms"]) == 2

    # Verify URL formats
    amazon_platform = next(p for p in data["platforms"] if p["platform"] == "amazon")
    flipkart_platform = next(
        p for p in data["platforms"] if p["platform"] == "flipkart"
    )

    assert amazon_platform["search_url"].startswith("https://www.amazon.in/s?k=")
    assert flipkart_platform["search_url"].startswith(
        "https://www.flipkart.com/search?q="
    )

    # Verify filters exist
    assert len(amazon_platform["filters"]) >= 3
    assert len(flipkart_platform["filters"]) >= 3


@pytest.mark.asyncio
async def test_multi_platform_same_prompt_produces_both_results():
    """Multi-platform: same prompt produces both amazon and flipkart results"""
    mock_message = MagicMock()
    mock_message.content = [MagicMock(text=json.dumps(MOCK_FULL_FLOW_RESPONSE))]

    with patch("src.app.services.anthropic.Anthropic") as mock_anthropic:
        mock_client = MagicMock()
        mock_client.messages.create.return_value = mock_message
        mock_anthropic.return_value = mock_client

        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as client:
            response = await client.post(
                "/api/intent/multi",
                json={"prompt": "white tshirt under 500 fast delivery"},
            )

    data = response.json()
    platforms = {p["platform"] for p in data["platforms"]}

    # Both platforms must be present
    assert platforms == {"amazon", "flipkart"}

    # Both should have search URLs
    for platform in data["platforms"]:
        assert "search_url" in platform
        assert len(platform["search_url"]) > 0
        assert "filters" in platform


@pytest.mark.asyncio
async def test_price_format_validation_under_rupee_x():
    """Price format validation: "Under ₹X" format in filters"""
    mock_message = MagicMock()
    mock_message.content = [MagicMock(text=json.dumps(MOCK_FULL_FLOW_RESPONSE))]

    with patch("src.app.services.anthropic.Anthropic") as mock_anthropic:
        mock_client = MagicMock()
        mock_client.messages.create.return_value = mock_message
        mock_anthropic.return_value = mock_client

        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as client:
            response = await client.post(
                "/api/intent/multi",
                json={"prompt": "tshirt under 500"},
            )

    data = response.json()

    # Check price filter format in both platforms
    for platform in data["platforms"]:
        price_filters = [f for f in platform["filters"] if f["type"] == "price"]
        if price_filters:
            price_value = price_filters[0]["value"]
            # Should follow "Under ₹X" format
            assert price_value.startswith("Under ₹") or price_value.startswith(
                "Under Rs"
            )
            # Extract numeric part and verify it's a number
            assert any(char.isdigit() for char in price_value)


@pytest.mark.asyncio
async def test_delivery_mapping_fast_delivery_to_prime_and_assured():
    """Delivery mapping: "fast delivery" → Prime (amazon) and Flipkart Assured (flipkart)"""
    mock_message = MagicMock()
    mock_message.content = [MagicMock(text=json.dumps(MOCK_FULL_FLOW_RESPONSE))]

    with patch("src.app.services.anthropic.Anthropic") as mock_anthropic:
        mock_client = MagicMock()
        mock_client.messages.create.return_value = mock_message
        mock_anthropic.return_value = mock_client

        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as client:
            response = await client.post(
                "/api/intent/multi",
                json={"prompt": "white tshirt fast delivery"},
            )

    data = response.json()

    amazon_platform = next(p for p in data["platforms"] if p["platform"] == "amazon")
    flipkart_platform = next(
        p for p in data["platforms"] if p["platform"] == "flipkart"
    )

    # Check Amazon has Prime
    amazon_delivery = [f for f in amazon_platform["filters"] if f["type"] == "delivery"]
    if amazon_delivery:
        assert amazon_delivery[0]["value"] == "Prime"

    # Check Flipkart has Flipkart Assured
    flipkart_delivery = [
        f for f in flipkart_platform["filters"] if f["type"] == "delivery"
    ]
    if flipkart_delivery:
        assert flipkart_delivery[0]["value"] == "Flipkart Assured"


@pytest.mark.asyncio
async def test_brand_extraction_appears_in_query_and_filters():
    """Brand extraction: brand name appears in both raw_query-related context and filters"""
    mock_message = MagicMock()
    mock_message.content = [MagicMock(text=json.dumps(MOCK_BRAND_RESPONSE))]

    with patch("src.app.services.anthropic.Anthropic") as mock_anthropic:
        mock_client = MagicMock()
        mock_client.messages.create.return_value = mock_message
        mock_anthropic.return_value = mock_client

        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as client:
            response = await client.post(
                "/api/intent/multi",
                json={"prompt": "nike tshirt under 1000"},
            )

    data = response.json()

    # Brand should be in raw_query or filters
    assert "nike" in data["raw_query"].lower()

    # Brand should be in filters for both platforms
    for platform in data["platforms"]:
        brand_filters = [f for f in platform["filters"] if f["type"] == "brand"]
        assert len(brand_filters) > 0
        assert any("nike" in f["value"].lower() for f in brand_filters)


@pytest.mark.asyncio
async def test_rating_filter_good_ratings_to_4_star_up():
    """Rating filter: "good ratings" → "4★ & up" """
    mock_message = MagicMock()
    mock_message.content = [MagicMock(text=json.dumps(MOCK_RATING_RESPONSE))]

    with patch("src.app.services.anthropic.Anthropic") as mock_anthropic:
        mock_client = MagicMock()
        mock_client.messages.create.return_value = mock_message
        mock_anthropic.return_value = mock_client

        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as client:
            response = await client.post(
                "/api/intent/multi",
                json={"prompt": "samsung phone good ratings"},
            )

    data = response.json()

    # Check rating filter format in both platforms
    for platform in data["platforms"]:
        rating_filters = [f for f in platform["filters"] if f["type"] == "rating"]
        if rating_filters:
            rating_value = rating_filters[0]["value"]
            # Should be "4★ & up" format
            assert "4" in rating_value
            assert "★" in rating_value or "star" in rating_value.lower()
            assert "up" in rating_value.lower()


@pytest.mark.asyncio
async def test_discount_filter_deals_to_10_percent_off():
    """Discount filter: "deals" → "10% off or more" """
    mock_message = MagicMock()
    mock_message.content = [MagicMock(text=json.dumps(MOCK_DISCOUNT_RESPONSE))]

    with patch("src.app.services.anthropic.Anthropic") as mock_anthropic:
        mock_client = MagicMock()
        mock_client.messages.create.return_value = mock_message
        mock_anthropic.return_value = mock_client

        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as client:
            response = await client.post(
                "/api/intent/multi",
                json={"prompt": "running shoes deals"},
            )

    data = response.json()

    # Check discount filter format in both platforms
    for platform in data["platforms"]:
        discount_filters = [f for f in platform["filters"] if f["type"] == "discount"]
        if discount_filters:
            discount_value = discount_filters[0]["value"]
            # Should contain percentage and "off"
            assert "%" in discount_value or "percent" in discount_value.lower()
            assert "off" in discount_value.lower()


@pytest.mark.asyncio
async def test_complex_prompt_multiple_filters_all_extracted():
    """Complex prompt with multiple filters → all extracted correctly"""
    mock_message = MagicMock()
    mock_message.content = [MagicMock(text=json.dumps(MOCK_COMPLEX_RESPONSE))]

    with patch("src.app.services.anthropic.Anthropic") as mock_anthropic:
        mock_client = MagicMock()
        mock_client.messages.create.return_value = mock_message
        mock_anthropic.return_value = mock_client

        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as client:
            response = await client.post(
                "/api/intent/multi",
                json={
                    "prompt": "nike running shoes under 2000 fast delivery good ratings"
                },
            )

    data = response.json()

    # Verify all expected filter types are present
    expected_filter_types = {"brand", "price", "delivery", "rating"}

    for platform in data["platforms"]:
        filter_types = {f["type"] for f in platform["filters"]}
        # Should have most or all of the expected types
        assert len(filter_types.intersection(expected_filter_types)) >= 3


@pytest.mark.asyncio
async def test_rank_endpoint_returns_top_5_with_platform_diversity():
    """Rank endpoint: given products from both platforms, returns top 5 with platform diversity"""
    mock_message = MagicMock()
    mock_message.content = [
        MagicMock(text=json.dumps({"indices": [2, 0, 3, 1, 4]}))  # Mixed platforms
    ]

    with patch("src.app.services.anthropic.Anthropic") as mock_anthropic:
        mock_client = MagicMock()
        mock_client.messages.create.return_value = mock_message
        mock_anthropic.return_value = mock_client

        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as client:
            response = await client.post(
                "/api/rank",
                json={
                    "query": "white tshirt under 500",
                    "products": SAMPLE_MIXED_PRODUCTS,
                },
            )

    assert response.status_code == 200
    data = response.json()
    ranked = data["ranked_products"]

    # Verify we got 5 products
    assert len(ranked) == 5

    # Verify platform diversity - should have products from both platforms
    platforms = {p["platform"] for p in ranked}
    assert len(platforms) >= 1  # At least one platform
    # In practice, with good ranking, should have both


@pytest.mark.asyncio
async def test_multi_platform_intent_plus_rank_pipeline():
    """Multi-platform intent + rank pipeline: extract intent → mock products → rank"""
    # Step 1: Extract multi-platform intent
    intent_mock_message = MagicMock()
    intent_mock_message.content = [MagicMock(text=json.dumps(MOCK_FULL_FLOW_RESPONSE))]

    # Step 2: Rank products
    rank_mock_message = MagicMock()
    rank_mock_message.content = [
        MagicMock(text=json.dumps({"indices": [2, 3, 0, 1, 4]}))
    ]

    with patch("src.app.services.anthropic.Anthropic") as mock_anthropic:
        mock_client = MagicMock()
        mock_client.messages.create.side_effect = [
            intent_mock_message,
            rank_mock_message,
        ]
        mock_anthropic.return_value = mock_client

        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as client:
            # Step 1: Get intent
            intent_response = await client.post(
                "/api/intent/multi",
                json={"prompt": "white tshirt under 500 fast delivery"},
            )

            assert intent_response.status_code == 200
            intent_data = intent_response.json()

            # Verify we got both platforms
            assert len(intent_data["platforms"]) == 2

            # Step 2: Rank mock products
            rank_response = await client.post(
                "/api/rank",
                json={
                    "query": intent_data["raw_query"],
                    "products": SAMPLE_MIXED_PRODUCTS,
                },
            )

            assert rank_response.status_code == 200
            rank_data = rank_response.json()

            # Verify ranking worked
            assert len(rank_data["ranked_products"]) == 5

            # Verify ranked products are valid
            for product in rank_data["ranked_products"]:
                assert "title" in product
                assert "price" in product
                assert "platform" in product
                assert product["platform"] in ["amazon", "flipkart"]


@pytest.mark.asyncio
async def test_end_to_end_flow_with_no_filters():
    """Test flow where prompt generates no specific filters"""
    mock_response = {
        "raw_query": "tshirt",
        "platforms": [
            {
                "platform": "amazon",
                "search_url": "https://www.amazon.in/s?k=tshirt",
                "filters": [],
            },
            {
                "platform": "flipkart",
                "search_url": "https://www.flipkart.com/search?q=tshirt",
                "filters": [],
            },
        ],
    }

    mock_message = MagicMock()
    mock_message.content = [MagicMock(text=json.dumps(mock_response))]

    with patch("src.app.services.anthropic.Anthropic") as mock_anthropic:
        mock_client = MagicMock()
        mock_client.messages.create.return_value = mock_message
        mock_anthropic.return_value = mock_client

        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as client:
            response = await client.post(
                "/api/intent/multi",
                json={"prompt": "tshirt"},
            )

    assert response.status_code == 200
    data = response.json()

    # Should still have valid structure even with no filters
    assert len(data["platforms"]) == 2
    for platform in data["platforms"]:
        assert "search_url" in platform
        assert "filters" in platform
        assert isinstance(platform["filters"], list)


@pytest.mark.asyncio
async def test_rank_preserves_product_metadata():
    """Verify rank endpoint preserves all product fields"""
    mock_message = MagicMock()
    mock_message.content = [MagicMock(text=json.dumps({"indices": [0, 1, 2, 3, 4]}))]

    with patch("src.app.services.anthropic.Anthropic") as mock_anthropic:
        mock_client = MagicMock()
        mock_client.messages.create.return_value = mock_message
        mock_anthropic.return_value = mock_client

        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as client:
            response = await client.post(
                "/api/rank",
                json={
                    "query": "white tshirt",
                    "products": SAMPLE_MIXED_PRODUCTS[:5],
                },
            )

    data = response.json()
    ranked = data["ranked_products"]

    # Verify all fields are preserved
    for product in ranked:
        assert "title" in product
        assert "price" in product
        assert "rating" in product
        assert "review_count" in product
        assert "image_url" in product
        assert "product_url" in product
        assert "platform" in product

        # Verify field types
        assert isinstance(product["price"], (int, float))
        assert product["platform"] in ["amazon", "flipkart"]


@pytest.mark.asyncio
async def test_filter_types_match_spec():
    """Verify all filter types from spec are handled correctly"""
    mock_response = {
        "raw_query": "test product",
        "platforms": [
            {
                "platform": "amazon",
                "search_url": "https://www.amazon.in/s?k=test+product",
                "filters": [
                    {"type": "brand", "value": "TestBrand"},
                    {"type": "price", "value": "Under ₹1,000"},
                    {"type": "delivery", "value": "Prime"},
                    {"type": "rating", "value": "4★ & up"},
                    {"type": "color", "value": "Blue"},
                    {"type": "size", "value": "XL"},
                    {"type": "discount", "value": "10% off or more"},
                ],
            },
            {
                "platform": "flipkart",
                "search_url": "https://www.flipkart.com/search?q=test+product",
                "filters": [
                    {"type": "brand", "value": "TestBrand"},
                    {"type": "price", "value": "Under ₹1,000"},
                    {"type": "delivery", "value": "Flipkart Assured"},
                    {"type": "rating", "value": "4★ & up"},
                    {"type": "color", "value": "Blue"},
                    {"type": "size", "value": "XL"},
                    {"type": "discount", "value": "10% off or more"},
                ],
            },
        ],
    }

    mock_message = MagicMock()
    mock_message.content = [MagicMock(text=json.dumps(mock_response))]

    with patch("src.app.services.anthropic.Anthropic") as mock_anthropic:
        mock_client = MagicMock()
        mock_client.messages.create.return_value = mock_message
        mock_anthropic.return_value = mock_client

        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as client:
            response = await client.post(
                "/api/intent/multi",
                json={"prompt": "test product with all filters"},
            )

    assert response.status_code == 200
    data = response.json()

    # Verify all specified filter types are present
    expected_types = {
        "brand",
        "price",
        "delivery",
        "rating",
        "color",
        "size",
        "discount",
    }

    for platform in data["platforms"]:
        filter_types = {f["type"] for f in platform["filters"]}
        assert expected_types == filter_types


@pytest.mark.asyncio
async def test_url_encoding_with_special_characters():
    """Verify search URLs handle special characters correctly"""
    mock_response = {
        "raw_query": "nike air max 90",
        "platforms": [
            {
                "platform": "amazon",
                "search_url": "https://www.amazon.in/s?k=nike+air+max+90",
                "filters": [],
            },
            {
                "platform": "flipkart",
                "search_url": "https://www.flipkart.com/search?q=nike+air+max+90",
                "filters": [],
            },
        ],
    }

    mock_message = MagicMock()
    mock_message.content = [MagicMock(text=json.dumps(mock_response))]

    with patch("src.app.services.anthropic.Anthropic") as mock_anthropic:
        mock_client = MagicMock()
        mock_client.messages.create.return_value = mock_message
        mock_anthropic.return_value = mock_client

        async with AsyncClient(
            transport=ASGITransport(app=app), base_url="http://test"
        ) as client:
            response = await client.post(
                "/api/intent/multi",
                json={"prompt": "nike air max 90"},
            )

    data = response.json()

    # Verify URL encoding - spaces should be + or %20
    for platform in data["platforms"]:
        url = platform["search_url"]
        # Should not have raw spaces
        assert " " not in url
        # Should have proper separators
        assert "+" in url or "%20" in url
